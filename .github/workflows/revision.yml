# # 1. Triggers (on) ‚Üí when it runs (push, PR, schedule, manual).
# on:
#   push:
#     branches: [master]

# # 2. Jobs ‚Üí isolated environments that run tasks.
# jobs:
#   build:
#     runs-on: ubuntu-latest

#     # 3. Steps ‚Üí commands or actions inside a job.
#     steps:
#       - uses: actions/checkout@v4
#       - run: echo "Hello World"

#       # 4. Actions ‚Üí prebuilt tasks (e.g., checkout code, setup Node.js).
#       - uses: actions/setup-node@v4
#         with:
#           node-version: 20

## Part 5: Learnig Plan for YAML (Step by Step)
# 1. Practice scalars (strings, numbers, booleans, null).
# 2. Practice lists (- item).
# 3. Practice maps (key: value).
# 4. Practice nesting (lists inside maps, maps inside lists).
# 5. Practice multiline strings (| and >).
# 6. Play with anchors (& and *).
# 7. Combine them all in small GitHub Actions workflows.

# # Q1:
# name: Abdul Hadi
# num: 12
# cache: null
# is_student: True

# # Q2:
# steps:
#   - Start VScode
#   - Make a .py file
#   - Start writing hello world code
#   - save it and run it

# # Q3:
# person:
#   name: Hadi
#   age: 19

# # Q4:

## Real- World YAML Lesson 1: A Github Action Workflow
# name: CI Pipeline
# on: # üëà triggers
#   push:
#     branches: [master] # run only when code pushed to master
#   pull_request: # also run on PRs

# jobs:
#   build:   # first job
#     runs-on: ubuntu-latest  # Github Runner Environment
#     steps:    # steps inside the job
#       - name: Checkout Repo
#         uses: actions/checkout@v4  # action (prebuilt step)

#       - name: Setup Node.js
#         uses: actions/setup-node@v4
#         with:
#           node-version: 20  # map under 'with'

#       - name: Install Dependencies
#         run: npm ci    # custom command

#       - name: Run Test
#         run: npm test

# üîç What you learned here:
# on = when workflow runs (events).
# jobs = big blocks of work.
# steps = ordered tasks inside a job.
# uses: = calling a prebuilt action.
# run: = running a shell command.

## Real-World YAML Lesson 2: Matrix Testing
# jobs:
#   test:
#     runs-on: ubuntu-latest
#     strategy:
#       matrix: # generate multiple jobs
#         python: ["3.10", "3.11", "3.12", "3.13"]

#     steps:
#       - uses: actions/checkout@v4
#       - uses: actions/setup-python@v5
#         with:
#           python-version: $ {{ matrix.python }}  # insert matrix var

#       - run: echo "Showing Python Version"
#       - run: python --version
# What you learned:
# - `strategy.matrix`  expands automatically.
# -  `$ {{ matrix.python }}` = interpolation (Github Syntax, not plain YAML)

## üöÄ Real-World YAML Lesson 3: Passing Artifacts Between Jobs
name: Passing Artifacts Between Jobs

on:
  push:
    branches: [ master, dev ]
  pull_request:

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Install deps if package.json exists
        run: |
          if [ -f package.json ]; then
            echo "package.json found ‚Üí running npm ci"
            npm ci
          else
            echo "No package.json ‚Üí skipping npm install"
          fi

      - name: Build (or create fallback artifact)
        run: |
          set -e
          # If there's a package.json, try the project's build script (if present).
          if [ -f package.json ]; then
            echo "Attempting npm run build --if-present"
            # --if-present returns 0 if no build script; if build script exists but fails, we fallback.
            if npm run build --if-present; then
              echo "Build succeeded (project build)"
            else
              echo "Build script failed ‚Üí creating fallback artifact"
              mkdir -p dist
              echo "<!-- fallback artifact: build failed -->" > dist/index.html
            fi
          else
            # No Node project: create a small dummy artifact so downstream jobs have something.
            echo "No package.json ‚Üí creating fallback artifact"
            mkdir -p dist
            echo "<!-- fallback artifact: no package.json -->" > dist/index.html
          fi

      - name: Inspect artifact folder
        run: ls -la dist || true

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: web-dist
          path: dist/

  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Download artifact published by build job
        uses: actions/download-artifact@v4
        with:
          name: web-dist

      - name: Show downloaded files (simulate deploy)
        run: |
          echo "Files available to deploy:"
          ls -la
          echo "Simulate deploy step here (scp, rsync, kubectl, etc.)"

## Real-World YAML Lesson 4: Conditions (Selective Deploy)
# Deploy only when branch is master
# jobs:
#   deploy:
#     runs-on: ubuntu-latest
#     # condition
#     if : $ {{ github.ref == 'refs/heads/master' }}
#     steps:
#       - run: echo "$ {{ github.ref }}"
#       - run: echo "Deploying to Production"
# What you learned:
# - if : applies conditionals at job or step-level
# - github.ref is a built-in Github Action variable

## Real-World YAML Lesson 5: Docker Build and Push
# jobs:
#   docker:
#     runs-on: ubuntu-latest
#     steps:
#       - uses: actions/checkout@v4

#       - name: Log in to registery   ## main issue in this, while running
#         run: echo $ {{ secrets.GITHUB_TOKEN }} | docker login dchr.io -u  ${{ github.actor }}  --password-stdin
      
#       - name: Build Image
#         run: docker build -t ghcr.io/$ {{ github.repository }}:latest .

#       - name: Push image
#         run: docker push ghcr.io/$ {{ github.repository }}:latest
